/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package AdminKeys;

import PublicKeys.KeyGen;
import static PublicKeys.KeyGen.getMiniKey;

/**
 *
 * @author lcv
 */
public class charCode {

//    public static final String ROOTLEX = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    /**
     * Atoms of strings to encode, by defauly
     */
    public static final String ROOTLEX = "aeioumndtsb0123456789";

    /**
     * Final set of atoms to encode
     */
    public String charSet,
            word;
    /**
     * Length of the final coda
     */
    protected int CODELENGTH,
            /**
             * Number of digits of every word to encode/decode
             */
            ndigits,
            /**
             * Offset used in CRC to shift the results
             */
            offset;
    /**
     * Canonical form of any word in any code: a Long Integer
     */
    protected long canonical;

    /**
     * If no code is specified, then the default code is used
     */
    public charCode() {
        initCode(ROOTLEX);
    }

    /**
     * If a new code is specified, it is used instead ROOTLEX
     *
     * @param code The new code
     */
    public charCode(String code) {
        initCode(code);
    }

    /**
     *
     * @return the canonical representation
     */
    public long getCanonical() {
        return this.canonical;
    }

    public String getWord() {
        return word;
    }

    /**
     * Reset the class
     *
     * @param code
     */
    protected void initCode(String code) {
        charSet = code;
        CODELENGTH = charSet.length();
    }

    /**
     * Checks if a given word could have been generated by the current code
     *
     * @param word
     * @return
     */
    public boolean belongs(String word) {
        for (char cs : word.toCharArray()) {
            if (charSet.indexOf(cs) < 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * Encodes the given word
     *
     * @param w
     * @return
     */
    protected charCode encode(String w) throws Exception {
        this.word = w;
        canonical = -1;
        if (!belongs(w)) {
            throw (new Exception("Word " + w + " does not fix within the code " + charSet));
        }
        canonical = 0;
        for (int i = 0; i < word.length(); i++) {
            char ichar = word.charAt(word.length() - i - 1);
            int kdigit = charSet.indexOf(ichar);
            canonical += kdigit * Math.pow(CODELENGTH, i);
        }
        return this;
    }

    protected void doRoll(int ntimes) {
        String aux = "";
        for (int i = 0; i < word.length(); i++) {
            int ch = charSet.indexOf(word.charAt(i));
            aux = aux + "" + charSet.charAt((ch + ntimes) % CODELENGTH);
        }
        System.out.println(word +" >>"+ntimes+">> "+aux);
        word = aux;

    }

    protected void doUnRoll(int ntimes) {
        String aux = "";
        for (int i = 0; i < word.length(); i++) {
            int ch = charSet.indexOf(word.charAt(i));
            aux = aux + "" + charSet.charAt((CODELENGTH + ch - ntimes) % CODELENGTH);
        }
        System.out.println(word +" <<"+ntimes+"<< "+aux);
        word = aux;

    }

    public charCode encode(String w, boolean crc) {
        word = w;
        if (crc) {
            offset = (int)(Math.max(1,checkSum(word) % CODELENGTH));
//            doRoll(offset);
            word = charSet.charAt(offset) + word;
        } else {
            offset = 0;
        }
        try {
            encode(word);
        } catch (Exception ex) {
        }
        if (canonical < 0) {
            return this;
        }
//        long precanonical=canonical;
//        if (crc) {
//            canonical = canonical * CODELENGTH + offset;
//        }
//        System.out.println("ENC: "+ word+","+precanonical+","+canonical);
        return this;
    }

    protected String decode(int ndigits) {
        word = "";

        long copy = canonical;
        while (copy > 0) {
            int idigit = (int) (copy % CODELENGTH);
//            idigit = (CODELENGTH + -offset + idigit) % CODELENGTH;
            word = "" + charSet.charAt(idigit) + word;
            copy /= CODELENGTH;
        }
//        word = "" + charSet.charAt((int) copy) + word;

        return word;
    }

    public String decode(boolean crc, int ndigits) {
        word = decode(ndigits);
        offset = charSet.indexOf(word.charAt(0));
        if (crc) {
            word = word.substring(1); //, word.length());
//            doUnRoll(offset);
        }
        while (word.length() < ndigits) {
            word = this.charSet.charAt(0) + word;
        }
//        System.out.println("DEC: " + res + "," + precanonical + "," + canonical);
        return word;
    }

    public String decode(charCode from, int ndigits, boolean crc) {
        canonical = from.canonical;
        return decode(crc, ndigits);
    }

    public String getKey() {
        return getKey(8);
    }

    public int checkSum(String w) {
        int checksum;
        canonical = -1;
        if (!belongs(w)) {
            return -1;
        }
        checksum = 0;
        for (int i = 0; i < w.length(); i++) {
            char ichar = w.charAt(w.length() - i - 1);
            int kdigit = charSet.indexOf(ichar);
            checksum += kdigit;
        }
        return checksum;
    }

    public String getKey(int length) {
        String newkey = "";
        final int len = length;
        for (int i = 0; i < len; i++) {
            newkey = newkey + charSet.charAt((int) (Math.random() * CODELENGTH) % CODELENGTH);
        }
        return newkey;
    }

    public static String getRootKey(int length) {
        String newkey = "";
        final int len = length;
        for (int i = 0; i < len; i++) {
            newkey = newkey + ROOTLEX.charAt((int) (Math.random() * ROOTLEX.length()) % ROOTLEX.length());
        }
        return newkey;
    }

    public String toString() {
        return "" + canonical;
    }

}
