\chapter{Implementación}

\section{Configuración del entorno en NetBeans 12}

El proceo de configuración del entorno en la plataforma de desarrollo NetBeans 12, la cual también usamos durante el desarrollo de la asignatura Desarrollo Basado en Agentes, fue cuanto menos tedioso. Todo el conglomerado de proyectos que posibilitan la ejecución de LATEN es necesario configurarlo, idealmente, a la vez y de manera uniforme.\\

Los diferentes proyetos fueron proporcionados por el tutor del proyecto de manera gradual, para de igual forma intentar acoplarlos al nuevo proyecto que se creó, perteneciente al propio agente LATEN. Esto en un primer momento ocasionó problemas de dependencias, tanto de proyectos como de archivos Java \textit{(con terminación .jar)}, incluso de otros paquetes de apoyo.\\

No obstante, tras unas horas de trabajo conjunto con el tutor, se pudo configurar de manera absoluta el proyecto LATEN.\\

Los proyectos de NetBeans de los que depende LATEN de una manera u otra, se listan a continuación:

\begin{itemize}
	\item BaseTelegram
	\item CoreLARVAAdminObjects
	\item CoreLARVAAgents
	\item CoreLARVAObjects
	\item CoreLARVAMoreObjects
	\item PTelegram
\end{itemize}

Adicionalmente, se requieren también los siguientes archivos con terminación \textit{.jar}:

\begin{itemize}
	\item Conector Java-MySQL, versión 8.0.25
	\item JADE
	\item La librería de utilidades Commons IO
\end{itemize}

Es importante mencionar también que se requiere de la versión 11 de JDK \textit{(\textbf{J}ava \textbf{D}evelopment \textbf{K}it)} para el correcto funcionamiento de todos los proyectos.\\

Una vez se tienen todos los proyectos correctamente importados, y las librerías debidamente incorportadas, se puede proceder con el resto de configuraciones necesarias antes de poder empezar con la implementación de nuestro agente.

\section{Configuración de la base de datos}

Con respecto a la configuración de la base de datos, el profesor de la asignatura me proporcionó un script SQL para poder tener una copia local de la base de datos tal y como se había usado para la asignatura. En dicha copia de la base de datos, se eliminaron aquellos datos de carácter sensible de otros alumnos que no influirían posteriormente en el propio proyecto, como por ejemplo el correo electrónico institucional de la Universidad de Granada o el número de identificación del chat personal de Telegram de cada alumno.\\

Para la gestión de la base de datos es buena práctica usar un cliente, ya sea web o con aplicación nativa, ya que permite una mejor visualización de toda la estructura de la base de datos, así como de los propios datos que alberga. Es evidente que también se puede usar la terminal de, en mi caso, el sistema operativo Ubuntu 20.04, para llevar a cabo todas las labores de gestión de la base de datos.\\

En mi caso, por preferencias personales, decidí instalar el gestor \textbf{phpMyAdmin}, el cual es una interfaz gráfica de usuario disponible a través de web, accediendo desde la dirección \textit{http://localhost/phpmyadmin}.\\

Para la instalación de dicho cliente desde la terminal de Ubuntu 20.04, se deben seguir unos pasos concretos. En primer lugar, se debe ejecutar el comando

\begin{lstlisting}
    sudo apt update
\end{lstlisting}

para actualizar la lista de paquetes disponibles y sus versiones. A continuación, el comando para proceder a la instalación del paquete de phpMyAdmin, así como de sus dependencias es el siguiente:

\begin{lstlisting}
    sudo apt install phpmyadmin php-mbstring php-gettext
\end{lstlisting}

Este comando, al ejecutarlo, nos ofrecerá una interfaz gráfica para especificar ciertos parámetros de configuración para el cliente. Entre ellos, deberemos establecer las contraseñas del usuario administrador de la base de datos, así como de la propia aplicación MySQL. Además, deberemos de seleccionar en qué servidor web queremos que se ejecute phpMyAdmin: \textit{apache2} o \textit{lighttpd}. Escogí \textit{apache2} por estar más familiarizado con el mismo.\\

Una vez completado el proceso de instalación mediante la terminal, ya podremos acceder a la interfaz gráfica a través del enlace anteriormente mencionado: \textit{http://localhost/phpmyadmin}.\\

El siguiente paso, será importar el script SQL que facilitó el tutor de la asignatura. Desde la interfaz gráfica, primeramente deberemos crear la base de datos en la que posteriormente importaremos dicho script. A la base de datos, le otorgué el nombre \textbf{LATEN}. Se puede crear una base de datos de manera muy sencilla como se muestra en la figura \ref{img:menubd1}. Basta con introducir el nombre de la base de datos que queremos crear y posteriormente pulsar sobre el botón \textbf{Crear}.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{logos/menubd1.png}\\[1.4cm]
\caption{Pestaña de creación de base de datos en phpMyAdmin}
\label{img:menubd1}
\end{figure}

Una vez creada la base de datos, navegaremos hacia ella a través de la interfaz gráfica y pulsaremos sobre el botón \textbf{Importar} del menú superior de phpMyAdmin. En esta ventana, podremos importar fácilmente el archivo con extensión \textit{.sql} aportado por el tutor de la asignatura, como se muestra en la figura \ref{img:menubd2}. Una vez cargado el script, presionaremos sobre el botón \textbf{Continuar} situado al pie de dicha página, y acto seguido tendremos disponible nuestra base de datos, con todas las tablas y con todos los datos correspondientes.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{logos/menubd2.png}\\[1.4cm]
\caption{Pestaña de importación en phpMyAdmin}
\label{img:menubd2}
\end{figure}


\section{Configuración y entorno de JADE}

Como se explicó en la sección \ref{sec:jade}, JADE es un framework que actuará de middleware entre nuestro sistema de agentes.\\

Su configuración es bastante sencilla. En la ya mencionada asignatura, se nos proporcionó un fichero comprimido que contiene todo lo necesario para la instalación de JADE. Con la siguiente secuencia de comandos, instalaremos de manera muy sencilla el paquete:

\begin{lstlisting}
    unzip dba-jade-kit.zip
    cd bin
    sudo ./install.sh
\end{lstlisting}

Una vez instalado, podemos ejecutar el servicio de JADE haciendo uso del siguiente comando:

\begin{lstlisting}
    sudo ./doJade.sh start
\end{lstlisting}

y de igual forma, cambiando el argumento, para detener el servicio:

\begin{lstlisting}
    sudo ./doJade.sh stop
\end{lstlisting}

Estas herramientas que acabamos de instalar también gozan de una interfaz gráfica desde la que observar todos los agentes que se encuentran disponibles en la plataforma además de las comunicaciones que se realizan entre ellos. Para ejecutar dicha interfaz gráfica, usaremos el siguiente comando:

\begin{lstlisting}
    sudo ./doJadeGUI.sh 
\end{lstlisting}

El cual, tras unos instantes nos mostrará una pantalla como la que se muestra en la figura \ref{img:jade1}.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{logos/jade1.png}\\[1.4cm]
\caption{Interfaz gráfica de JADE}
\label{img:jade1}
\end{figure}

\section{Configuración del agente}

Para que nuestro agente se integre de manera correcta en la red con el resto de agentes que ya habitan en ella, es necesario especificar ciertos parámetros de configuración que posteriormente serán leídos por las clases correspondientes que lanzan dicho agente a la plataforma JADE. Estos parámetros de configuración se establecerán en formato JSON, dentro de una carpeta llamada \textit{config} del mismo proyecto de nuestro agente LATEN.\\

Dichos parámetros de configuración son los que se muestran a continuación:

\begin{lstlisting}
    {
        "name": "LATEN",
        "version": "1.0",
        "silent": false,
        "log": true,
        "system": true,
        "showbehaviour": false,
        "singlebehaviour": true,
        "boot": "jade",
        "jadeconnection": {
            "host": "localhost",
            "port": 1099
        },
        "dbconnection": {
            "host": "localhost",
            "port": 3306,
            "database": "LATEN",
            "user": "username",
            "password": "password"
        }
    }
\end{lstlisting}

A destacar de este archivo de configuración, podemos ver el elemento \textbf{singlebehaviour}, el cual tiene como valor asignado \textit{true}, lo cual indica que dicho agente tiene un solo comportamiento y por tanto no es necesario establecer configuraciones adicionales a la hora de lanzar dicho agente, como por ejemplo sería establecer un sistema de colas múltiple para la recepción de mensajes ACL.\\

Otros elementos como \textbf{silent}, \textbf{log} o \textbf{system}, tienen como propósito informar al desarrollador sobre los distintos acontecimientos durante la ejecución de dicho agente. Se pueden configurar a \textbf{true} o \textbf{false} para ajustar la cantidad de información que queremos recibir de la ejecución.\\

Adicionalmente, tenemos un elemento de configuración de la conexión de JADE llamado \textbf{jadeconnection}, en el que podemos especificar el \textbf{host} y el \textbf{puerto \textit{(port)}} a través de los cuales se puede establecer una conexión con JADE.\\

Por último, tenemos el elemento \textbf{dbconnection} que posee toda la configuración necesaria para establecer conexión con la base de datos previamente configurada.

\section{Implementación}

\subsection{Agente LATEN}

El agente LATEN en un inicio se planificó como el agente encargado de interactuar con el resto de los agentes de la red, haciendo de puente entre aquellos agentes destinados a la resolución de las prácticas, como los ya mencionados \textbf{WorldManagers} y entre el propio bot de Telegram.

\subsubsection{Clase principal}

En todo el ecosistema ya mencionado, los agentes se lanzan a la plataforma esencialmente de la misma forma, con quizás algunos cambios. Se puede apreciar en el siguiente fragmento de código, en el que explicaré brevemente en qué consiste cada línea.

\begin{lstlisting}
    static ConsoleBoot _app;

    public static void main(String[] args) {
        _app = new ConsoleBoot("LATEN", args);
        _app.selectConnection();
        _app.launchAgent(LATEN.class);
        _app.shutDown();
    }
\end{lstlisting}

Para comenzar, creamos un objeto de clase de la clase \textbf{ConsoleBoot}, la cual es una clase creada por el profesor de la asignatura para ejecutar aplicaciones JADE con todo lo necesario para que los agentes se puedan ejecutar \textbf{(y ser cerrados)} de manera segura ya sea en nuestra máquina local o en remoto.\\

El siguiente método \textbf{selectConnection()}, selecciona la conexión que hayamos definido en nuestro archivo de configuración JSON, ya sea nuestra máquina local o una máquina remota, como podría ser el propio servidor de la asignatura para realizar las propias prácticas.\\

\textbf{launchAgent()} básicamente lanza al agente a la plataforma y el método \textbf{shutDown()} cerrará el agente junto con los contenedores creados cuando el método \textbf{plainExecute()} de la clase \textbf{LATEN} termine de ejecutarse y por tanto haya finalizado el trabajo del agente.

\subsubsection{El método plainExecute()}

Este es el método principal de la clase \textbf{LATEN}. Es el que se ejecutará durante toda la vida útil del agente. El propósito actual de dicho agente es el de leer, interpretar y actuar sobre los distintos registros de las sesiones prácticas de la asignatura. Al comienzo de este proyecto, el tutor me facilitó los registros reales de las prácticas del grupo de prácticas al que yo pertenecía durante la asignatura, los cuales usé para poder implementar y probar esta funcionalidad.\\

Al lanzar el agente LATEN a la plataforma, para proceder a la lectura e interpretación de los registros, se siguen los siguientes pasos:\\

\begin{enumerate}
    \item Identificar el grupo al que pertenece dicho registro
    \item Identificar los miembros de dicho grupo
    \item Obtener los ajustes de noticaciones específicos de cada usuario del grupo
    \item Analizar cada línea y enviar los mensajes correspondientes al agente de Telegram para que éste informe a los miembros correspondientes
\end{enumerate}

Los tres primeros puntos de la lista anterior se pueden observar, de manera breve en el siguiente fragmento de código:

\begin{lstlisting}
    // Identify which group does this communication belong to
    this.group = this.identifyGroup(myReader.nextLine());
    
    // Verify which members do we have to send the message to
    // First, obtain the groupID
    JsonObject groupID = _dataBase.queryJsonDB("SELECT groupID FROM LATEN.Groups WHERE alias='" + this.group + "'").getRowByIndex(0);
    
    // Members belonging to that group
    JsonArray usersID = _dataBase.queryJsonDB("SELECT userID FROM GroupMembers WHERE cardID IS NOT NULL AND groupID=" + groupID.get("groupID")).getAllRows();
    
    for(int i = 0; i < usersID.size(); i++) {
        this.groupMembers.add(usersID.get(i).asObject());
    }
    
    // Adds the notifications settings for each user
    for(JsonObject groupMember : this.groupMembers) {
        JsonObject usersNotifications = 
                _dataBase.queryJsonDB("SELECT notificationSettings FROM Users WHERE userID=" + groupMember.get("userID")).getRowByIndex(0);
        
        groupMember.add("notificationSettings", usersNotifications.get("notificationSettings"));
    }
\end{lstlisting}

Como se puede observar, se realizan varias consultas a la base de datos y estos datos se van almacenando en ciertas variables de la clase para su posterior uso.\\

Con respecto al último punto, al comienzo del método se declaran las siguientes variables, que sirven para abrir y leer el archivo correspondiente de las sesiones:

\begin{lstlisting}
    File ficheroSesiones = new File(sessionFile);
    Scanner myReader = new Scanner(ficheroSesiones);
\end{lstlisting}

De tal forma, una vez se hayan hecho todas las consultas necesarias a la base de datos y almacenado los datos correspondientes, podremos iterar sobre cada línea del registro con un bucle y así analizar y actuar sobre cada línea:

\begin{lstlisting}
    while(myReader.hasNextLine()) {
        String linea = myReader.nextLine();
        
        JsonObject jsonLine = Json.parse(linea).asObject();
        String info;
        
        if (linea.contains("acl_receive_REGULAR") && linea.contains("\"command\":\"login\"")) {
            // This is a notification marked as ALL
            String newConvIDs = this.buildNotificationString("ALL");                
            
            sendMessage("PTelegram", ACLMessage.AGREE, "REGULAR", Emojis.ENVELOPE + " Sending login request...", newConvIDs);
            
        } else if (linea.contains("acl_send_REGULAR") && linea.contains("Login request from")) { [...]
\end{lstlisting}

\subsubsection{Métodos auxiliares}

En el método \textbf{plainExecute()} se han podido observar otras funciones auxiliares que se programaron para modularizar lo máximo posible el agente y hacerlo así más legible, y sobre todo más mantenible de cara a un futuro. A continuación se comentan las más relevantes:\\

La primera que procedo a comentar es quizás la más destacable y la más usada, ya que en cada condición diferente del bucle principal del método \textbf{plainExecute()} se usa. Es la función encargada de mandar un mensaje a un determinado agente de la plataforma. Recibe ciertos parámetros como el nombre del agente, la performativa a enviar, o el contenido, como se puede observar a continuación:\\

\begin{lstlisting}
    /**
     * Sends a message
     * @param receiver Message's receiver
     * @param performative The performative to use
     * @param protocol Message's protocol
     * @param content Message's content
     * @param conversationID The conversation ID to send the message to
     */
    protected void sendMessage(String receiver, int performative, String protocol, String content, String conversationID) {
        ACLMessage out = new ACLMessage();
        out.setSender(this.getAID());
        out.addReceiver(new AID(receiver, AID.ISLOCALNAME));
        out.setPerformative(performative);
        out.setProtocol(protocol);
        out.setContent(content);

        if(conversationID != "") {
            out.setConversationId(conversationID);
        }

        this.send(out);
    }
\end{lstlisting}

Como observamos en la función anterior, es necesario proveer de un \textit{conversationID}, que es esencialmente una cadena de caracteres, que puede estar separada por espacios, en la que se indica cada uno de los chats a los que se les debe entregar cada mensaje. Así pues, en la siguiente función lo que se hace es constuir esa cadena de caracteres en base a las preferencias de notificaciones de cada usuario:\\

\begin{lstlisting}
    /**
     * Returns an updated list of conversation IDs to send the notifications
     * @param notification rank
     * @return String containing the conversation IDs
     */
    protected String buildNotificationString(String notification) {
        String convIDs = "";
        
        for (JsonObject groupMember : this.groupMembers) {
            for (String type : notification.trim().split(" ")) {
                if (groupMember.get("notificationSettings").toString().replaceAll("\"", "").equals(type)) {
                    convIDs = convIDs + " " + groupMember.get("userID").toString();
                }
            }
        }
        
        return convIDs;
    }
\end{lstlisting}

De tal modo, en la siguiente línea se especifica que se debe enviar ese mensaje concreto, a aquellos usuarios que tengan las preferencias de notificaciones en \textit{''ALL''}:\\

\begin{lstlisting}
    // This is a notification marked as ALL
    String newConvIDs = this.buildNotificationString("ALL");
\end{lstlisting}

Como ya se ha comentado en otras ocasiones, debido a falta de tiempo y otros diversos problemas, no se ha podido proceder al lanzamiento de este agente a la plataforma con el resto de agentes de la asignatura. Se comentarán más detalles en la sección de trabajos futuros.

\subsection{Agente PTelegram \textit{(Public Telegram)}}

\subsubsection{Clase principal}

\subsubsection{El método plainExecute()}

\subsubsection{Métodos auxiliares}

\subsection{Resto de clases y utilidades}

\section{Diagrama de clases}

\section{Ejemplo de comunicación entre agentes}